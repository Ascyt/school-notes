<!DOCTYPE html><meta charset=UTF-8><title>2 NoSQL Theorie</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><style>body,html{height:100%;font-family:Arial,sans-serif;margin:0}#header{display:flex;align-items:center;background-color:#f0f0f0;padding:10px}#title{flex:1;font-size:24px}#navbar{display:flex}#navbar .tab-button{margin-left:10px;padding:6px 12px;background-color:#e0e0e0;border:0;cursor:pointer;font-size:16px}#navbar .tab-button.active{background-color:#ccc;font-weight:bold}#content{display:flex;height:calc(100% - 50px)}#sidebar{width:200px;min-width:50px;max-width:1000px;background-color:#e0e0e0;overflow-y:auto;position:relative}#sidebar-content a{display:block;padding:8px 12px;text-decoration:none;color:#000}#sidebar-content a:hover{background-color:#ccc}#sidebar-resizer{width:5px;cursor:ew-resize;position:absolute;top:0;right:0;bottom:0;background-color:#d0d0d0;user-select:none}#main{flex:1;padding:20px;overflow-y:auto}#main h2{margin-bottom:10px;border-bottom:1px solid #ccc;padding-bottom:5px}#main p{margin-bottom:20px;line-height:1.6}@media(max-width:600px){#header{flex-direction:column;align-items:flex-start}#tabs{margin-top:10px}#content{flex-direction:column}#sidebar{width:100%;max-width:none;min-width:0;height:200px}#sidebar-resizer{display:none}}#parents{margin-bottom:20px}table{border-collapse:collapse;margin:20px 0;font-size:18px;min-width:400px}th,td{padding:12px 15px;border:1px solid #e0e0e0;text-align:left}th{background-color:#c0c0c0;font-weight:bold}tr:nth-child(even){background-color:#d0d0d0}tr:hover{background-color:#c0c0c0}img{width:500px;height:auto}.katex-display .katex{text-align:left;margin-left:20px}</style><div id=header><div id=title>2 NoSQL Theorie</div><div id=navbar></div></div><div id=content><div id=sidebar><div id=sidebar-content><a id=SECTION-BTN_einfuhrung href=#SECTION_einfuhrung onclick='onSectionClick("einfuhrung")'>Einführung</a><a id=SECTION-BTN_arten href=#SECTION_arten onclick='onSectionClick("arten")'>Arten</a><a id=SECTION-BTN_vertikale-vs-horizontale-skalierung href=#SECTION_vertikale-vs-horizontale-skalierung onclick='onSectionClick("vertikale-vs-horizontale-skalierung")'>Vertikale vs. horizontale Skalierung</a><a id=SECTION-BTN_acid href=#SECTION_acid onclick='onSectionClick("acid")'>ACID</a><a id=SECTION-BTN_base href=#SECTION_base onclick='onSectionClick("base")'>BASE</a><a id=SECTION-BTN_cap-theorem href=#SECTION_cap-theorem onclick='onSectionClick("cap-theorem")'>CAP-Theorem</a><a id=SECTION-BTN_netzwerkpartitionierung href=#SECTION_netzwerkpartitionierung onclick='onSectionClick("netzwerkpartitionierung")'>Netzwerkpartitionierung</a><a id=SECTION-BTN_cap-dreieck href=#SECTION_cap-dreieck onclick='onSectionClick("cap-dreieck")'>CAP-Dreieck</a><a id=SECTION-BTN_cap-in-der-praxis href=#SECTION_cap-in-der-praxis onclick='onSectionClick("cap-in-der-praxis")'>CAP in der Praxis</a><a id=SECTION-BTN_ca-systeme href=#SECTION_ca-systeme onclick='onSectionClick("ca-systeme")'>CA-Systeme?</a><a id=SECTION-BTN_wahrscheinlichkeiten href=#SECTION_wahrscheinlichkeiten onclick='onSectionClick("wahrscheinlichkeiten")'>Wahrscheinlichkeiten</a><a id=SECTION-BTN_yield--harvest href=#SECTION_yield--harvest onclick='onSectionClick("yield--harvest")'>Yield & Harvest</a><a id=SECTION-BTN_yield--harvest---beispiel href=#SECTION_yield--harvest---beispiel onclick='onSectionClick("yield--harvest---beispiel")'>Yield & Harvest - Beispiel</a><a id=SECTION-BTN_pacelc href=#SECTION_pacelc onclick='onSectionClick("pacelc")'>PACELC</a></div><div id=sidebar-resizer></div></div><div id=main><div id=parents><a href="/index.html">root</a> / <a href="/4CHIF/index.html">4CHIF</a> / <a href="/4CHIF/DBI/index.html">DBI</a> / <b>2 NoSQL Theorie</b></div><div class=section id=SECTION_einfuhrung><h1>Einführung</h1><p><strong>NoSQL</strong> = <strong>N</strong>ot <strong>o</strong>nly <strong>SQL</strong><p>Bedeutung: Datenbanken, die einen <strong>nicht relationalen Ansatz</strong> verfolgen.<ul><li><strong>Relationale DBs</strong> haben Leistungsprobleme bei datenintensiven Applikationen <span class=math>\(\rightarrow\)</span> nur effizient, wenn sie für häufige, aber kleine Transaktionen oder für große Batch-Transaktionen mit seltenen Schreibzugriffen optimiert sind <span class=math>\(\rightarrow\)</span> können schlecht mit gleichzeitig hohen Datenanforderungen und häufigen Datenänderungen umgehen.<li><strong>NoSQL-Architekturen</strong> bieten meist nur schwache Garantien hinsichlich Konsistenz und eingeschränkte Transaktionen, sie sind auf steigende Datenmenden und häufige Datenänderungen ausgelegt. (Ausnahmen bestätigen die Regel.)</li></ul><p><img src=assets/nosql-1.png alt="Grafik 1"> <img src=assets/nosql-2.png alt="Grafik 2"></p></div><div class=section id=SECTION_arten><h1>Arten</h1><p>[ Mehr dazu in <a href=/4chif/dbi/3%20nosql%20datenbanken>3 NoSQL Datenbanken</a> ]<ul><li><strong>Document-based</strong><ul><li>Dokumente als JSON, BSON oder XML<li>Schnell &amp; flexibel</li></ul><li><strong>Key-Value-Stores</strong><ul><li>Einfachste Form<li>Sehr schnell</li></ul><li><strong>Column-Oriented</strong><ul><li>Daten in Spalten statt in Zeilen<li>Skalierbar, effizient</li></ul><li><strong>Graph-Based</strong><ul><li>Konzentriet sich auf Beziehungen zwischen Elementen</li></ul></li></ul><p><img src=assets/nosql-3.png alt="Grafik 3"></p></div><div class=section id=SECTION_vertikale-vs-horizontale-skalierung><h1>Vertikale vs. horizontale Skalierung</h1><p>Ansätze zur Verbesserung der Leistung und Kapazität eines Datenbanksystems, insbesondere wenn die Datenmenge oder die Anzahl der Anfragen zunimmt.<ul><li><strong>Vertikale Skalierung</strong>: Leistung eines Servers erhöhen<li><strong>Horizontale Skalierung</strong>: Mehrere Servers verwenden</li></ul><p><img src=assets/nosql-4.png alt="Grafik 4"><h2>Vertikale Skalierung (Scale Up)</h2><p>Leistung eines einzelnen Servers wird erhöht, indem man dessen Hardware aufrüstet:<ul><li>Erhöhung der CPU-Leistung (schnellere Prozessoren, mehr Kerne)<li>Hinzufügen von mehr Arbeitsspeicher (RAM)<li>Verwendung schnellerer Festplatten (z.B. SSDs statt HDDs)<li>Netzwerk-Upgrades für höhere Bandbreite</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Einfach umzusetzen</strong>: Die bestehende Architektur bleibt erhalten, keine Änderungen an der Anwendung oder Datenbankstruktur notwending<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Von den meisten relationalen DBs unterstützt</strong><br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Begrenzte Skalierung</strong>: Hardware-Upgrades haben physische und wirtschaftliche Grenzen.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Single Point of Failure</strong>: Wenn der Server ausfällt, ist das gesamte System betroffen.<h2>Horizontale Skalierung (Scale Out)</h2><p>Zusätzliche Server (Knoten) werden in das System eingebunden, um die Last zu verteilen:<ul><li>Verteilung der Daten auf mehrere Server (Sharding)<li>Replikation der Daten auf mehrere Knoten (Datenkopien zur Erhöhung der Verfügbarkeit)<li>Verwendung von Load-Balancern, um Anfragen auf mehrere Server zu verteilen</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Unbegrenzte Skalierbarkeit</strong>: Theoretisch können so viele Server wie nötig hinzugefügt werden. Ideal für Anwendungen mit wachsendem Datenvvolumen oder hohen Benutzerzahlen.<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Höhere Verfügbarkeit</strong>: Wenn ein Knoten ausfällt, können andere Knoten die Arbeit übernehmen (Fehlertoleranz).<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Kosteneffizienz</strong>: Statt teurer High-End-Hardware können günstigere Standard-Server verwendet werden.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Komplexität</strong>: Verteilte Systeme sind schwerer zu verwalten, erfordern Mechanismen wie Sharding, Replikation und Konsistenzmanagement.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Eventual Consistency</strong>: Um horizontale Skalierung zu ermöglichen, wird manchmal die Konsistenz geopfert.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Nicht geeignet für relationale DBs</strong>: Erfordert Einsatz aufwändiger Anpassungen.</p></div><div class=section id=SECTION_acid><h1>ACID</h1><p>ACID beschriebt gewünschte Eigenschaften von Transaktionen. Dieses ist für verteilte NoSQL-Datenbanken zu strikt, weshalb diese auf einem anderen Prinzip basieren:<p><img src=assets/acid.png alt=ACID></p></div><div class=section id=SECTION_base><h1>BASE</h1><ul><li><strong>B</strong>asically <strong>A</strong>vailable:<br> NoSQL-Datenbanken prioritisieren Verfügbarkeit auch bei Ausfällen. Das System bleibt funktionsfähig, liefert immer eine Antwort auf Anfragen--entweder erfolgreich oder als Fehler--und toleriert dabei vorüber Inkonsistenzen.<li><strong>S</strong>oft-State:<br> Der Zustand des Systems kann sich ohne direkte Anfragen verändern, da Konsistenz in NoSQL-Datenbanken nicht sofort, sondern mit der Zeit erreicht wird. Es dauert, bis alle Knoten eines verteilten Systems synchronisiert sind.<li><strong>E</strong>ventually Consistent:<br> Datenkopien auf verschiedenen Knoten werden nach und nach synchronisiert. Am Ende sind sie konsistent, auch wenn es vorübergehend Inkonsistenzen gibt. Dies ermöglicht schnelle Reaktionen bei großen Datenmengen.</li></ul></div><div class=section id=SECTION_cap-theorem><h1>CAP-Theorem</h1><p>Konzept, dass die Kompromisse zwischen Konsistenz, Verfügbarkeit und Partitionstoleranz <strong>in verteilten Systemen</strong> erklärt.<ul><li><strong>Konsistenz</strong> bezieht sich auf die Eigenschaft eines Systems, bei dem alle Knoten eine konsistente Ansicht der Daten haben. Das bedeutet, dass alle Clients zur gleichen Zeit die gleichen Daten sehen, unabhängig davon, mit welchem Knoten sie verbunden sind.<li><strong>Verfügbarkeit</strong> bezieht sich auf die Fähigkeit eines Systems, jederzeit auf Anfragen von Nutzern zu reagieren.<li><strong>Partitionstoleranz</strong> bezieht sich auf die Fähigkeit eines Systems, auch bei einer Netzwerkpartition weiter zu arbeiten.</li></ul></div><div class=section id=SECTION_netzwerkpartitionierung><h1>Netzwerkpartitionierung</h1><p>Eine Netzwerkpartition tritt auf, wenn Knoten in einem verteilten System aufgrund von Netzwerkfehlern nicht mehr miteinander kommunizieren können. Wenn eine Netzwerkpartiion auftritt, muss sich das System zwischen Konsistenz und Verfügbarkeit entscheiden.<p><img src=assets/netzwerkpartitionierung.png alt=Netzwerkpartitionierung><p>Wenn das System <strong>Konsistenz</strong> prioritisiert, kann es bis zur Behebung der Partition nicht verfügbar sein.<p>Wenn das System <strong>Verfügbarkeit</strong> prioritisiert, kann es Aktualisierungen an den Daten zulassen, was zu inkonsistenzen führen kann, bis die Partition behoben ist.<p><img src=assets/netzwerpartitionierung2.png alt="Netzwerkpartitionierung 2"><h2>Beispiel: Bank</h2><p>Kleine Bank mit 2 Bankomaten, die über ein Netzwerk verbunden sind. Kontostand darf niemals unter 0 fallen!<p><img src=assets/bank1.png alt="Bank 1"><p>Es gibt keine zentrale DB, die den Kontostand speichert; er wird auf beiden Bakomaten gespeichert. Wenn ein Kunde einen Bankomaten benutzt, wird der Kontostand auf beiden Bankomaten über das Netzwerk aktualisiert <span class=math>\(\rightarrow\)</span> Bankomaten haben eine konsistente Ansicht des Kontostands.<p><img src=assets/bank2.png alt="Bank 2"><p>Netzwerkpartition <span class=math>\(\rightarrow\)</span> Bankomaten können nicht mehr miteinander kommunizieren <span class=math>\(\rightarrow\)</span> System muss zwischen Konsistenz und Verfügbarkeit wählen.<p><strong>Konsistenz</strong>: Geldautomat könnte die Verarbeitung von Einzahlungen oder Abhebungen verweigern, bis die Partition behoben ist. Dadurch bleibt der Kontostand konsistent, aber das System ist für Kunden nicht verfügbar.<p><strong>Verfügbarkeit</strong>: Könnte für Bank teuer werden. Kunde könnte den gesamten Kontostand an beiden Geldautomaten abheben. Wenn das Netzwerk wieder online ist, wird die Inkonsistenz behoben, und der Kontostand ist jetzt negativ:<p>Aus diesen Gründen ist es besser, wenn man für eine Bank die <strong>Konsistenz</strong> prioritisiert, da falsche Daten schwere Auswirkungen haben könnten.<p><img src=assets/bank3.png alt="Bank 3"><h2>Beispiel: Social Media</h2><p><img src=assets/socialmedia.png alt="Social Media"><p>Während einer Netzwerkpartition muss wieder zwischen Verfügbarkeit und Konsistenz wählen.<p><strong>Verfügbarkeit</strong>: Es könnte es sein, dass 2 Nutzer gleichzeitig einen Kommentar zu demselben Beitrag abgeben, aber der Kommentar eines Nutzers für den anderen erst sichtbar wird, wenn die Partition behoben ist.<p><strong>Konsistenz</strong>: Die Kommentarfunktion könnte für Nutzer bis zur Behebung der Partition nicht verfügbar sein.<p>Für ein soziales Netzwerk ist es oft akzeptabel, <strong>Verfügbarkeit</strong> zu prioritiseren, auch wenn die Nutzer hin und wieder leicht unterschiedliche Ansichten sehen.</p></div><div class=section id=SECTION_cap-dreieck><h1>CAP-Dreieck</h1><p>Das CAP-Dreieck besagt, dass jede Datenbank nur maximal <strong>zwei</strong> von <strong>Availability</strong>, <strong>Consistency</strong> bzw. <strong>Partition Tolerance</strong> unterstützen kann.<p><img src=assets/cap-dreieck-1.png alt="CAP-Dreieck 1"><p><img src=assets/cap-dreieck-2.png alt="CAP-Dreieck 2"></p></div><div class=section id=SECTION_cap-in-der-praxis><h1>CAP in der Praxis</h1><p><em>Quelle: <a href=https://www.alexdebrie.com/posts/when-does-cap-theorem-apply/>https://www.alexdebrie.com/posts/when-does-cap-theorem-apply/</a></em><h2>Beispiel 1</h2><p>Einzelknoteninstanz einer relationalen DB.<p>Cron-Job, der Logs löscht, aber falsch konfiguriert ist <span class=math>\(\Rightarrow\)</span> Festplatte füllt sich mit Logs und DB stürzt ab.<p>CAP? CAP ist nicht anwendbar auf Einzelknoten. Deine einzelne DB-Instanz ist ausgefallen <span class=math>\(\rightarrow\)</span> nicht lustig! :(<p><a href=assets/cap-bsp-1.png>Beispiel 1</a><h2>Beispiel 2</h2><p>Wir fügen Replikation hinzu und haben jetzt einen Cluster mit drei Knoten.<p>Wieder falscher Cron-Job <span class=math>\(\rightarrow\)</span> Festplatte von einem Knoten voll, ein Knoten fällt aus <span class=math>\(\rightarrow\)</span> andere 2 Knoten übernehmen Last.<p>CAP? CAP nicht anwendbar, da nur Knoten ausgefallen und keine Netzwerkpartition <span class=math>\(\rightarrow\)</span> geringere Verfügbarkeit <span class=math>\(\rightarrow\)</span> weniger schlimm, aber auch nicht lustig :(<h2>Beispiel 3</h2><p>Wie Beispiel 2, aber jetzt kann ein Knoten aufgrund einer Netzwerkpartition mit anderen 2 nicht mehr kommunizieren.<p>CAP? CAP! System entscheidet, eine erfolgreiche Antwort vom isolierten Knoten auszugeben, auch wenn dieser eventuell nicht über den neuesten Stand der Daten von anderen Knoten verfügt (Verlust von Konsistenz) <span class=math>\(\rightarrow\)</span> <strong>AP</strong><p>Höhere Verfügbarkeit: Alle 3 Knoten könenn antworten. Es werden fehlerhafte Anfragen reduziert, die in Beispiel 2 durch überlastete Knoten enstanden wären.<p><img src=assets/cap-bsp-3.png alt="Beispiel 3"><h2>Beispiel 4</h2><p>Wie Beispiel 3, aber diesmal erlauben wir dem isolierten Knoten nicht, auf Client-Anfragen zu antworten.<p>CAP? CAP! Wir opfern Verfügbarkeit <span class=math>\(\rightarrow\)</span> <strong>CP</strong><p>Clientanforderungen, die unseren isolierten Knoten erreichen, erhalten einen Fehler, was unsere Verfügbarkeitszahlen reduziert.<p><img src=assets/cap-bsp-4.png alt="Beispiel 4"><h2>Beispiel 5</h2><p>Wieder isolierter Knoten durch Netzwerkpartitionierung <span class=math>\(\rightarrow\)</span> empfängt eine Leseanforderung für ein Datenelement <span class=math>\(\rightarrow\)</span> anstatt sofort zu antworten, wartet der Knoten.<p>42 Tage später ist die Netzwerkpartitionierung repariert <span class=math>\(\rightarrow\)</span> Knoten empfängt alle Aktualisierungen und antwortet dem Client mit einer konsistenten Ansicht der angeforderten Daten.<p>CAP? Eventuell nicht anwendbar oder: yeah, wir haben das CAP-Theorem besiegt :) ...<p>Verfügbarkeitsaspekt von CAP hat keine Zeitkomponente als Teil der Anfrage. Obwohl die meisten Kunden eine schnellere Antwort bevorzugen würden, <em>könnten</em> wir wohl warten, bis die Partition aufgelöst ist.<p>Theoretisch haben wir hier <strong>CA</strong> <span class=math>\(\rightarrow\)</span> wir opfern die Partionstoleranz, indem wir einfach warten, bis sie verschwindet <span class=math>\(\rightarrow\)</span> nicht lustig :(<p><img src=assets/cap-bsp-5.png alt="Beispiel 5"></p></div><div class=section id=SECTION_ca-systeme><h1>CA-Systeme?</h1><p>CA-Systeme (Konsistenz+Verfügbarkeit) funktionieren <strong>nur ohne Partitionen</strong>. Da Partitionen in verteilten Systemen unvermeidbar sind, ist diese Kombination unrealistisch oder nicht praktikabel. Das CAP-Theorem ist nur anwendbar, wenn es Netzwerkpartitionen gibt.<p>Streng genommen geht es beim CAP-Theorem also immer um eine Entscheidung zwischen Konsistenz (CP) und Verfügbarkeit (AP) und beides (CA) ist gar keine Option!<p>Damit ein verteiltes System keine Partitionstoleranz benötigt, müsste es in einem Netzwerk laufen, das garantiert niemals Nachrichten verliern (oder verspätet zustellt) und dessen Knoten garantiert niemals ausfallen. Wir arbeiten aber nicht mit solchen Systemen, weil es sie nicht gibt.<p><img src=assets/cap-comic.png alt=CAP-Comic></p></div><div class=section id=SECTION_wahrscheinlichkeiten><h1>Wahrscheinlichkeiten</h1><p>Die Wahrscheinlichkeit, dasss ein Knoten ausfällt, steigt exponentiell mit der Anzahl der Knoten:<div class=math>\[ P(\text{jeder Fehler}) = 1-P(\text{einzelner Knoten fällt nicht aus})^{\text{Anzahl der Knoten}} \]</div><p>Wenn ein einzelner Knoten eine Wahrscheinlichkeit von <span class=math>\(99.9\%\)</span> hat, in einem bestimmten Zeitraum nicht auszufallen, liegt die Wahrscheinlichkeit bei einem Cluster von 40 Knoten bei <span class=math>\(96.1\%\)</span>. Mit anderen Worten, die Wahrscheinlichkeit, dass etwas schief geht, liegt bei etwa <span class=math>\(4\%\)</span>. (Und dabei wird davon ausgegangen, dass die Ausfälle nichts miteinander zu tun haben; in Wirklichkeit neigen sie dazu, sich kaskadierend zu häufen.)</p></div><div class=section id=SECTION_yield--harvest><h1>Yield & Harvest</h1><p>Statt sich darauf zu konzentrieren, welche 2 dieser 3 Eigenschaften am wichtigsten sind, sollten wir uns darauf fokussieren, welche Kompromisse ein System eingeht, wenn es zu Problemen kommt. Ein nützlicher Ansatz dabei ist das Konzept von <strong><em>yield</em> (Ertrag)</strong> und <strong><em>harvest</em> (Ernte)</strong>.<p><strong>Yield</strong> beschreibt die Wahrscheinlichkeit, dass eine Anfrage erfolgreich abgeschlossen wird. In der Praxis ist dies oft ein besserer Indikator für die Benutzererrfahrung als die bloße Betriebszeit, da nicht alle Ausfälle die gleiche Auswirkung haben.<p><strong>Harvest</strong> bezieht sich auf die Vollständigkeit der Antwort. Wenn Teile eines Systems ausfallen, könnte das System dennoch Daten aus den funktionierenden Teilen liefern, was jedoch die Ernte verringert.<p>Systeme, die Fehler handhaben, können sich auf den Ertrag oder die Ernte auswirken. Replizierte Systeme führen in der Regel zu einer verringerten Kapazität, während partitionierte Systeme oft eine reduzierte Ernte zur Folge haben, da Daten temporär verloren gehen können.<p>Entwickler sollen sich bewusst sein, dass Fehler unvermeidlich sind und das System entweder den Ertrag oder die Ernte reduzieren muss. Diese Entscheidung sollte von den Geschäftsanforderungen abhähngen.</p></div><div class=section id=SECTION_yield--harvest---beispiel><h1>Yield & Harvest - Beispiel</h1><p>System, das Lagerbestände in verschiedenen regionen verwaltet. Das System wird genutzt, um zu prüfen, ob ein Artikel in einer Filiale verfügbar ist.<p>Der Bestand wir in drei Regionen gespeichert:<ul><li>Region A: Lagerbestand in OÖ<li>Region B: Lagerbestand in Salzburg<li>Region C: Lagerbestand in NÖ</li></ul><p>Ein Kunde sucht nach einem Latpopt und möchte wissen, ob er in einer beliebigen Region verfügbar ist.<p><strong>Situation</strong>: Region B ist momentan nicht verfügbar (z.B. Netzwerkprobleme).<ol><li><strong>Hoher Yield, Niedriger Harvest</strong>:<br> Das System liefert eine Antwort basierend auf den Beständen von Region A und Region C. Es informiet die Nutzer, dass der Laptop in den OÖ und NÖ verfügbar ist, aber keine Informationen über Salzburg hat.<br> Yield bleibt hoch, da der Kunde eine Antwort erhält.<br> Harvest, ist niedrig, da nicht alle Daten (Region B) berücksichtigt wurden.<li><strong>Niedriger Yield, Hoher Harvest</strong>:<br> Das System entscheided, keine Antwort zu geben, bis die Daten aus allen Regionen verfügbar sind.<br> Yield ist niedrig, da der Kunde keine sofortige Antwort erhält.<br> Harvest ist hoch, da der Kunde später eine vollständige und korrekte Übersicht über alle Lagerbestände bekommt.</li></ol><p>Hoher Harvest ist sinnvoll bei z.B. medizinischen Daten (Diagnose mit unvollständigen Daten ist gefährlich), Versicherungsansprüche, Routenplanung, Cybersecurity, ...</p></div><div class=section id=SECTION_pacelc><h1>PACELC</h1><p>Steht für: <strong>Partition</strong> <span class=math>\(\rightarrow\)</span> <strong>Availability, Consistency, Else</strong> <span class=math>\(\rightarrow\)</span> <strong>Latency and Consistency</strong><p><img src=assets/pacelc.png alt=PACELC><p>Besagt, dass man sich bei einer Netzwerkpartitionierung (<strong>P</strong>) und in einem verteilten Computersystem zwischen Verfügbarkeit (<strong>A</strong>) und Konsistenz (<strong>C</strong>) entscheiden muss.<p>Andernfalls (<strong>E</strong>) muss man sich jedoch, selbst wenn das System ohne Partitionen normal läuft, zwischen Latenz (<strong>L</strong>) und Konsistenzverlust (<strong>C</strong>) entscheiden.<p>PACELC verdeutlicht, dass der Kompromiss zwischen Konsistenz und Verfügbarkeit (<strong>CAP</strong>) nur die halbe Wahrheit ist: <strong>Im Normalbetrieb müssen Entwickler immer noch Entscheidungen treffen, die die Systemleistung und Nutzererfahrung beeinflussen.</strong> Diese feinere Betrachtung hilft, die Wahl der Datenbank oder Systemarchitektur besser auf die Anforderungen der Anwendung abzustimmen.<p><img src=assets/pacelc-2.png alt="PACELC 2"></p></div></div></div><script>function onTabClick(n){currentTab=n;tabButtons.forEach(t=>{t.id==="TAB-BTN_"+n?t.classList.add("active"):t.classList.remove("active")});tabContents.forEach(t=>{t.style.display=t.id==="TAB_"+n?"block":"none"});tabSidebars.forEach(t=>{t.style.display=t.id==="TAB-SIDEBAR_"+n?"block":"none"})}let currentTab="";const tabButtons=document.querySelectorAll(".tab-button"),tabContents=document.querySelectorAll(".tab"),tabSidebars=document.querySelectorAll(".tab-sidebar");tabButtons.length>0&&tabButtons[0].click();const sidebar=document.getElementById("sidebar"),resizer=document.getElementById("sidebar-resizer");let isResizing=!1;resizer.addEventListener("mousedown",function(){isResizing=!0});document.addEventListener("mousemove",function(n){if(isResizing){let t=n.clientX-sidebar.getBoundingClientRect().left;t<50&&(t=50);t>1e3&&(t=1e3);sidebar.style.width=t+"px"}});document.addEventListener("mouseup",function(){isResizing=!1})</script>