<!DOCTYPE html><meta charset=UTF-8><title>2 NoSQL Theorie</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><style>body,html{height:100%;font-family:Arial,sans-serif;margin:0}#header{display:flex;align-items:center;background-color:#f0f0f0;padding:10px}#title{flex:1;font-size:24px}#navbar{display:flex}#navbar .tab-button{margin-left:10px;padding:6px 12px;background-color:#e0e0e0;border:0;cursor:pointer;font-size:16px}#navbar .tab-button.active{background-color:#ccc;font-weight:bold}#content{display:flex;height:calc(100% - 50px)}#sidebar{width:200px;min-width:50px;max-width:1000px;background-color:#e0e0e0;overflow-y:auto;position:relative}#sidebar-content a{display:block;padding:8px 12px;text-decoration:none;color:#000}#sidebar-content a:hover{background-color:#ccc}#sidebar-resizer{width:5px;cursor:ew-resize;position:absolute;top:0;right:0;bottom:0;background-color:#d0d0d0;user-select:none}#main{flex:1;padding:20px;overflow-y:auto}#main h2{margin-bottom:10px;border-bottom:1px solid #ccc;padding-bottom:5px}#main p{margin-bottom:20px;line-height:1.6}@media(max-width:600px){#header{flex-direction:column;align-items:flex-start}#tabs{margin-top:10px}#content{flex-direction:column}#sidebar{width:100%;max-width:none;min-width:0;height:200px}#sidebar-resizer{display:none}}#parents{margin-bottom:20px}table{border-collapse:collapse;margin:20px 0;font-size:18px;min-width:400px}th,td{padding:12px 15px;border:1px solid #e0e0e0;text-align:left}th{background-color:#c0c0c0;font-weight:bold}tr:nth-child(even){background-color:#d0d0d0}tr:hover{background-color:#c0c0c0}img{width:500px;height:auto}.katex-display .katex{text-align:left;margin-left:20px}</style><div id=header><div id=title>2 NoSQL Theorie</div><div id=navbar></div></div><div id=content><div id=sidebar><div id=sidebar-content><a id=SECTION-BTN_einfuhrung href=#SECTION_einfuhrung onclick='onSectionClick("einfuhrung")'>Einführung</a><a id=SECTION-BTN_arten href=#SECTION_arten onclick='onSectionClick("arten")'>Arten</a><a id=SECTION-BTN_vertikale-vs-horizontale-skalierung href=#SECTION_vertikale-vs-horizontale-skalierung onclick='onSectionClick("vertikale-vs-horizontale-skalierung")'>Vertikale vs. horizontale Skalierung</a><a id=SECTION-BTN_acid href=#SECTION_acid onclick='onSectionClick("acid")'>ACID</a><a id=SECTION-BTN_base href=#SECTION_base onclick='onSectionClick("base")'>BASE</a><a id=SECTION-BTN_cap-theorem href=#SECTION_cap-theorem onclick='onSectionClick("cap-theorem")'>CAP-Theorem</a><a id=SECTION-BTN_netzwerkpartitionierung href=#SECTION_netzwerkpartitionierung onclick='onSectionClick("netzwerkpartitionierung")'>Netzwerkpartitionierung</a><a id=SECTION-BTN_cap-dreieck href=#SECTION_cap-dreieck onclick='onSectionClick("cap-dreieck")'>CAP-Dreieck</a></div><div id=sidebar-resizer></div></div><div id=main><div id=parents><a href="/index.html">root</a> / <a href="/4CHIF/index.html">4CHIF</a> / <a href="/4CHIF/DBI/index.html">DBI</a> / <b>2 NoSQL Theorie</b></div><div class=section id=SECTION_einfuhrung><h1>Einführung</h1><p><strong>NoSQL</strong> = <strong>N</strong>ot <strong>o</strong>nly <strong>SQL</strong><p>Bedeutung: Datenbanken, die einen <strong>nicht relationalen Ansatz</strong> verfolgen.<ul><li><strong>Relationale DBs</strong> haben Leistungsprobleme bei datenintensiven Applikationen <span class=math>\(\rightarrow\)</span> nur effizient, wenn sie für häufige, aber kleine Transaktionen oder für große Batch-Transaktionen mit seltenen Schreibzugriffen optimiert sind <span class=math>\(\rightarrow\)</span> können schlecht mit gleichzeitig hohen Datenanforderungen und häufigen Datenänderungen umgehen.<li><strong>NoSQL-Architekturen</strong> bieten meist nur schwache Garantien hinsichlich Konsistenz und eingeschränkte Transaktionen, sie sind auf steigende Datenmenden und häufige Datenänderungen ausgelegt. (Ausnahmen bestätigen die Regel.)</li></ul><p><img src=assets/nosql-1.png alt="Grafik 1"> <img src=assets/nosql-2.png alt="Grafik 2"></p></div><div class=section id=SECTION_arten><h1>Arten</h1><p>[ Mehr dazu in <a href=/4chif/dbi/3%20nosql%20datenbanken>3 NoSQL Datenbanken</a> ]<ul><li><strong>Document-based</strong><ul><li>Dokumente als JSON, BSON oder XML<li>Schnell &amp; flexibel</li></ul><li><strong>Key-Value-Stores</strong><ul><li>Einfachste Form<li>Sehr schnell</li></ul><li><strong>Column-Oriented</strong><ul><li>Daten in Spalten statt in Zeilen<li>Skalierbar, effizient</li></ul><li><strong>Graph-Based</strong><ul><li>Konzentriet sich auf Beziehungen zwischen Elementen</li></ul></li></ul><p><img src=assets/nosql-3.png alt="Grafik 3"></p></div><div class=section id=SECTION_vertikale-vs-horizontale-skalierung><h1>Vertikale vs. horizontale Skalierung</h1><p>Ansätze zur Verbesserung der Leistung und Kapazität eines Datenbanksystems, insbesondere wenn die Datenmenge oder die Anzahl der Anfragen zunimmt.<ul><li><strong>Vertikale Skalierung</strong>: Leistung eines Servers erhöhen<li><strong>Horizontale Skalierung</strong>: Mehrere Servers verwenden</li></ul><p><img src=assets/nosql-4.png alt="Grafik 4"><h2>Vertikale Skalierung (Scale Up)</h2><p>Leistung eines einzelnen Servers wird erhöht, indem man dessen Hardware aufrüstet:<ul><li>Erhöhung der CPU-Leistung (schnellere Prozessoren, mehr Kerne)<li>Hinzufügen von mehr Arbeitsspeicher (RAM)<li>Verwendung schnellerer Festplatten (z.B. SSDs statt HDDs)<li>Netzwerk-Upgrades für höhere Bandbreite</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Einfach umzusetzen</strong>: Die bestehende Architektur bleibt erhalten, keine Änderungen an der Anwendung oder Datenbankstruktur notwending<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Von den meisten relationalen DBs unterstützt</strong><br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Begrenzte Skalierung</strong>: Hardware-Upgrades haben physische und wirtschaftliche Grenzen.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Single Point of Failure</strong>: Wenn der Server ausfällt, ist das gesamte System betroffen.<h2>Horizontale Skalierung (Scale Out)</h2><p>Zusätzliche Server (Knoten) werden in das System eingebunden, um die Last zu verteilen:<ul><li>Verteilung der Daten auf mehrere Server (Sharding)<li>Replikation der Daten auf mehrere Knoten (Datenkopien zur Erhöhung der Verfügbarkeit)<li>Verwendung von Load-Balancern, um Anfragen auf mehrere Server zu verteilen</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Unbegrenzte Skalierbarkeit</strong>: Theoretisch können so viele Server wie nötig hinzugefügt werden. Ideal für Anwendungen mit wachsendem Datenvvolumen oder hohen Benutzerzahlen.<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Höhere Verfügbarkeit</strong>: Wenn ein Knoten ausfällt, können andere Knoten die Arbeit übernehmen (Fehlertoleranz).<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Kosteneffizienz</strong>: Statt teurer High-End-Hardware können günstigere Standard-Server verwendet werden.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Komplexität</strong>: Verteilte Systeme sind schwerer zu verwalten, erfordern Mechanismen wie Sharding, Replikation und Konsistenzmanagement.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Eventual Consistency</strong>: Um horizontale Skalierung zu ermöglichen, wird manchmal die Konsistenz geopfert.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Nicht geeignet für relationale DBs</strong>: Erfordert Einsatz aufwändiger Anpassungen.</p></div><div class=section id=SECTION_acid><h1>ACID</h1><p>ACID beschriebt gewünschte Eigenschaften von Transaktionen. Dieses ist für verteilte NoSQL-Datenbanken zu strikt, weshalb diese auf einem anderen Prinzip basieren:<p><img src=assets/acid.png alt=ACID></p></div><div class=section id=SECTION_base><h1>BASE</h1><ul><li><strong>B</strong>asically <strong>A</strong>vailable:<br> NoSQL-Datenbanken prioritisieren Verfügbarkeit auch bei Ausfällen. Das System bleibt funktionsfähig, liefert immer eine Antwort auf Anfragen--entweder erfolgreich oder als Fehler--und toleriert dabei vorüber Inkonsistenzen.<li><strong>S</strong>oft-State:<br> Der Zustand des Systems kann sich ohne direkte Anfragen verändern, da Konsistenz in NoSQL-Datenbanken nicht sofort, sondern mit der Zeit erreicht wird. Es dauert, bis alle Knoten eines verteilten Systems synchronisiert sind.<li><strong>E</strong>ventually Consistent:<br> Datenkopien auf verschiedenen Knoten werden nach und nach synchronisiert. Am Ende sind sie konsistent, auch wenn es vorübergehend Inkonsistenzen gibt. Dies ermöglicht schnelle Reaktionen bei großen Datenmengen.</li></ul></div><div class=section id=SECTION_cap-theorem><h1>CAP-Theorem</h1><p>Konzept, dass die Kompromisse zwischen Konsistenz, Verfügbarkeit und Partitionstoleranz <strong>in verteilten Systemen</strong> erklärt.<ul><li><strong>Konsistenz</strong> bezieht sich auf die Eigenschaft eines Systems, bei dem alle Knoten eine konsistente Ansicht der Daten haben. Das bedeutet, dass alle Clients zur gleichen Zeit die gleichen Daten sehen, unabhängig davon, mit welchem Knoten sie verbunden sind.<li><strong>Verfügbarkeit</strong> bezieht sich auf die Fähigkeit eines Systems, jederzeit auf Anfragen von Nutzern zu reagieren.<li><strong>Partitionstoleranz</strong> bezieht sich auf die Fähigkeit eines Systems, auch bei einer Netzwerkpartition weiter zu arbeiten.</li></ul></div><div class=section id=SECTION_netzwerkpartitionierung><h1>Netzwerkpartitionierung</h1><p>Eine Netzwerkpartition tritt auf, wenn Knoten in einem verteilten System aufgrund von Netzwerkfehlern nicht mehr miteinander kommunizieren können. Wenn eine Netzwerkpartiion auftritt, muss sich das System zwischen Konsistenz und Verfügbarkeit entscheiden.<p><img src=assets/netzwerkpartitionierung.png alt=Netzwerkpartitionierung><p>Wenn das System <strong>Konsistenz</strong> prioritisiert, kann es bis zur Behebung der Partition nicht verfügbar sein.<p>Wenn das System <strong>Verfügbarkeit</strong> prioritisiert, kann es Aktualisierungen an den Daten zulassen, was zu inkonsistenzen führen kann, bis die Partition behoben ist.<p><img src=assets/netzwerpartitionierung2.png alt="Netzwerkpartitionierung 2"><h2>Beispiel: Bank</h2><p>Kleine Bank mit 2 Bankomaten, die über ein Netzwerk verbunden sind. Kontostand darf niemals unter 0 fallen!<p><img src=assets/bank1.png alt="Bank 1"><p>Es gibt keine zentrale DB, die den Kontostand speichert; er wird auf beiden Bakomaten gespeichert. Wenn ein Kunde einen Bankomaten benutzt, wird der Kontostand auf beiden Bankomaten über das Netzwerk aktualisiert <span class=math>\(\rightarrow\)</span> Bankomaten haben eine konsistente Ansicht des Kontostands.<p><img src=assets/bank2.png alt="Bank 2"><p>Netzwerkpartition <span class=math>\(\rightarrow\)</span> Bankomaten können nicht mehr miteinander kommunizieren <span class=math>\(\rightarrow\)</span> System muss zwischen Konsistenz und Verfügbarkeit wählen.<p><strong>Konsistenz</strong>: Geldautomat könnte die Verarbeitung von Einzahlungen oder Abhebungen verweigern, bis die Partition behoben ist. Dadurch bleibt der Kontostand konsistent, aber das System ist für Kunden nicht verfügbar.<p><strong>Verfügbarkeit</strong>: Könnte für Bank teuer werden. Kunde könnte den gesamten Kontostand an beiden Geldautomaten abheben. Wenn das Netzwerk wieder online ist, wird die Inkonsistenz behoben, und der Kontostand ist jetzt negativ:<p>Aus diesen Gründen ist es besser, wenn man für eine Bank die <strong>Konsistenz</strong> prioritisiert, da falsche Daten schwere Auswirkungen haben könnten.<p><img src=assets/bank3.png alt="Bank 3"><h2>Beispiel: Social Media</h2><p><img src=assets/socialmedia.png alt="Social Media"><p>Während einer Netzwerkpartition muss wieder zwischen Verfügbarkeit und Konsistenz wählen.<p><strong>Verfügbarkeit</strong>: Es könnte es sein, dass 2 Nutzer gleichzeitig einen Kommentar zu demselben Beitrag abgeben, aber der Kommentar eines Nutzers für den anderen erst sichtbar wird, wenn die Partition behoben ist.<p><strong>Konsistenz</strong>: Die Kommentarfunktion könnte für Nutzer bis zur Behebung der Partition nicht verfügbar sein.<p>Für ein soziales Netzwerk ist es oft akzeptabel, <strong>Verfügbarkeit</strong> zu prioritiseren, auch wenn die Nutzer hin und wieder leicht unterschiedliche Ansichten sehen.</p></div><div class=section id=SECTION_cap-dreieck><h1>CAP-Dreieck</h1><p>Das CAP-Dreieck besagt, dass jede Datenbank nur maximal <strong>zwei</strong> von <strong>Availability</strong>, <strong>Consistency</strong> bzw. <strong>Partition Tolerance</strong> unterstützen kann.<p><img src=assets/cap-dreieck-1.png alt="CAP-Dreieck 1"><p><img src=assets/cap-dreieck-2.png alt="CAP-Dreieck 2"></p></div></div></div><script>function onTabClick(n){currentTab=n;tabButtons.forEach(t=>{t.id==="TAB-BTN_"+n?t.classList.add("active"):t.classList.remove("active")});tabContents.forEach(t=>{t.style.display=t.id==="TAB_"+n?"block":"none"});tabSidebars.forEach(t=>{t.style.display=t.id==="TAB-SIDEBAR_"+n?"block":"none"})}let currentTab="";const tabButtons=document.querySelectorAll(".tab-button"),tabContents=document.querySelectorAll(".tab"),tabSidebars=document.querySelectorAll(".tab-sidebar");tabButtons.length>0&&tabButtons[0].click();const sidebar=document.getElementById("sidebar"),resizer=document.getElementById("sidebar-resizer");let isResizing=!1;resizer.addEventListener("mousedown",function(){isResizing=!0});document.addEventListener("mousemove",function(n){if(isResizing){let t=n.clientX-sidebar.getBoundingClientRect().left;t<50&&(t=50);t>1e3&&(t=1e3);sidebar.style.width=t+"px"}});document.addEventListener("mouseup",function(){isResizing=!1})</script>