<!DOCTYPE html><meta charset=UTF-8><title>2 NoSQL Theorie</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><style>body,html{height:100%;font-family:Arial,sans-serif;margin:0}#header{display:flex;align-items:center;background-color:#f0f0f0;padding:10px}#title{flex:1;font-size:24px}#navbar{display:flex}#navbar .tab-button{margin-left:10px;padding:6px 12px;background-color:#e0e0e0;border:0;cursor:pointer;font-size:16px}#navbar .tab-button.active{background-color:#ccc;font-weight:bold}#content{display:flex;height:calc(100% - 50px)}#sidebar{width:200px;min-width:50px;max-width:1000px;background-color:#e0e0e0;overflow-y:auto;position:relative}#sidebar-content a{display:block;padding:8px 12px;text-decoration:none;color:#000}#sidebar-content a:hover{background-color:#ccc}#sidebar-resizer{width:5px;cursor:ew-resize;position:absolute;top:0;right:0;bottom:0;background-color:#d0d0d0;user-select:none}#main{flex:1;padding:20px;overflow-y:auto}#main h2{margin-bottom:10px;border-bottom:1px solid #ccc;padding-bottom:5px}#main p{margin-bottom:20px;line-height:1.6}@media(max-width:600px){#header{flex-direction:column;align-items:flex-start}#tabs{margin-top:10px}#content{flex-direction:column}#sidebar{width:100%;max-width:none;min-width:0;height:200px}#sidebar-resizer{display:none}}#parents{margin-bottom:20px}table{border-collapse:collapse;margin:20px 0;font-size:18px;min-width:400px}th,td{padding:12px 15px;border:1px solid #e0e0e0;text-align:left}th{background-color:#c0c0c0;font-weight:bold}tr:nth-child(even){background-color:#d0d0d0}tr:hover{background-color:#c0c0c0}img{width:500px;height:auto}.katex-display .katex{text-align:left;margin-left:20px}</style><div id=header><div id=title>2 NoSQL Theorie</div><div id=navbar></div></div><div id=content><div id=sidebar><div id=sidebar-content><a id=SECTION-BTN_einfuhrung href=#SECTION_einfuhrung onclick='onSectionClick("einfuhrung")'>Einführung</a><a id=SECTION-BTN_arten href=#SECTION_arten onclick='onSectionClick("arten")'>Arten</a><a id=SECTION-BTN_vertikale-vs-horizontale-skalierung href=#SECTION_vertikale-vs-horizontale-skalierung onclick='onSectionClick("vertikale-vs-horizontale-skalierung")'>Vertikale vs. horizontale Skalierung</a></div><div id=sidebar-resizer></div></div><div id=main><div id=parents><a href="/index.html">root</a> / <a href="/4CHIF/index.html">4CHIF</a> / <a href="/4CHIF/DBI/index.html">DBI</a> / <b>2 NoSQL Theorie</b></div><div class=section id=SECTION_einfuhrung><h1>Einführung</h1><p><strong>NoSQL</strong> = <strong>N</strong>ot <strong>o</strong>nly <strong>SQL</strong><p>Bedeutung: Datenbanken, die einen <strong>nicht relationalen Ansatz</strong> verfolgen.<ul><li><strong>Relationale DBs</strong> haben Leistungsprobleme bei datenintensiven Applikationen <span class=math>\(\rightarrow\)</span> nur effizient, wenn sie für häufige, aber kleine Transaktionen oder für große Batch-Transaktionen mit seltenen Schreibzugriffen optimiert sind <span class=math>\(\rightarrow\)</span> können schlecht mit gleichzeitig hohen Datenanforderungen und häufigen Datenänderungen umgehen.<li><strong>NoSQL-Architekturen</strong> bieten meist nur schwache Garantien hinsichlich Konsistenz und eingeschränkte Transaktionen, sie sind auf steigende Datenmenden und häufige Datenänderungen ausgelegt. (Ausnahmen bestätigen die Regel.)</li></ul><p><img src=assets/nosql-1.png alt="Grafik 1"> <img src=assets/nosql-2.png alt="Grafik 2"></p></div><div class=section id=SECTION_arten><h1>Arten</h1><p>[ Mehr dazu in <a href=/4chif/dbi/3%20nosql%20datenbanken>3 NoSQL Datenbanken</a> ]<ul><li><strong>Document-based</strong><ul><li>Dokumente als JSON, BSON oder XML<li>Schnell &amp; flexibel</li></ul><li><strong>Key-Value-Stores</strong><ul><li>Einfachste Form<li>Sehr schnell</li></ul><li><strong>Column-Oriented</strong><ul><li>Daten in Spalten statt in Zeilen<li>Skalierbar, effizient</li></ul><li><strong>Graph-Based</strong><ul><li>Konzentriet sich auf Beziehungen zwischen Elementen</li></ul></li></ul><p><img src=assets/nosql-3.png alt="Grafik 3"></p></div><div class=section id=SECTION_vertikale-vs-horizontale-skalierung><h1>Vertikale vs. horizontale Skalierung</h1><p>Ansätze zur Verbesserung der Leistung und Kapazität eines Datenbanksystems, insbesondere wenn die Datenmenge oder die Anzahl der Anfragen zunimmt.<ul><li><strong>Vertikale Skalierung</strong>: Leistung eines Servers erhöhen<li><strong>Horizontale Skalierung</strong>: Mehrere Servers verwenden</li></ul><p><img src=assets/nosql-4.png alt="Grafik 4"><h2>Vertikale Skalierung (Scale Up)</h2><p>Leistung eines einzelnen Servers wird erhöht, indem man dessen Hardware aufrüstet:<ul><li>Erhöhung der CPU-Leistung (schnellere Prozessoren, mehr Kerne)<li>Hinzufügen von mehr Arbeitsspeicher (RAM)<li>Verwendung schnellerer Festplatten (z.B. SSDs statt HDDs)<li>Netzwerk-Upgrades für höhere Bandbreite</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Einfach umzusetzen</strong>: Die bestehende Architektur bleibt erhalten, keine Änderungen an der Anwendung oder Datenbankstruktur notwending<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Von den meisten relationalen DBs unterstützt</strong><br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Begrenzte Skalierung</strong>: Hardware-Upgrades haben physische und wirtschaftliche Grenzen.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Single Point of Failure</strong>: Wenn der Server ausfällt, ist das gesamte System betroffen.<h2>Horizontale Skalierung (Scale Out)</h2><p>Zusätzliche Server (Knoten) werden in das System eingebunden, um die Last zu verteilen:<ul><li>Verteilung der Daten auf mehrere Server (Sharding)<li>Replikation der Daten auf mehrere Knoten (Datenkopien zur Erhöhung der Verfügbarkeit)<li>Verwendung von Load-Balancern, um Anfragen auf mehrere Server zu verteilen</li></ul><p><span class=math>\(\textcolor{lime}{+}\)</span> <strong>Unbegrenzte Skalierbarkeit</strong>: Theoretisch können so viele Server wie nötig hinzugefügt werden. Ideal für Anwendungen mit wachsendem Datenvvolumen oder hohen Benutzerzahlen.<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Höhere Verfügbarkeit</strong>: Wenn ein Knoten ausfällt, können andere Knoten die Arbeit übernehmen (Fehlertoleranz).<br> <span class=math>\(\textcolor{lime}{+}\)</span> <strong>Kosteneffizienz</strong>: Statt teurer High-End-Hardware können günstigere Standard-Server verwendet werden.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Komplexität</strong>: Verteilte Systeme sind schwerer zu verwalten, erfordern Mechanismen wie Sharding, Replikation und Konsistenzmanagement.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Eventual Consistency</strong>: Um horizontale Skalierung zu ermöglichen, wird manchmal die Konsistenz geopfert.<br> <span class=math>\(\textcolor{red}{-}\)</span> <strong>Nicht geeignet für relationale DBs</strong>: Erfordert Einsatz aufwändiger Anpassungen.</p></div></div></div><script>function onTabClick(n){currentTab=n;tabButtons.forEach(t=>{t.id==="TAB-BTN_"+n?t.classList.add("active"):t.classList.remove("active")});tabContents.forEach(t=>{t.style.display=t.id==="TAB_"+n?"block":"none"});tabSidebars.forEach(t=>{t.style.display=t.id==="TAB-SIDEBAR_"+n?"block":"none"})}let currentTab="";const tabButtons=document.querySelectorAll(".tab-button"),tabContents=document.querySelectorAll(".tab"),tabSidebars=document.querySelectorAll(".tab-sidebar");tabButtons.length>0&&tabButtons[0].click();const sidebar=document.getElementById("sidebar"),resizer=document.getElementById("sidebar-resizer");let isResizing=!1;resizer.addEventListener("mousedown",function(){isResizing=!0});document.addEventListener("mousemove",function(n){if(isResizing){let t=n.clientX-sidebar.getBoundingClientRect().left;t<50&&(t=50);t>1e3&&(t=1e3);sidebar.style.width=t+"px"}});document.addEventListener("mouseup",function(){isResizing=!1})</script>